//
//  Crypto.swift
//  IDSignQRGenerator
//
//  Created by Francesco Bianco on 22/12/21.
//

import Foundation
import Security

public struct SecurityRSA {
    
    public static var preferredAlgorithm: SecKeyAlgorithm = .rsaEncryptionPKCS1
    public static var bundle: String = {
        return Bundle.main.bundleIdentifier ?? "com.certificatehelper"
    }()
    
    
    
    // MARK: - API
    
    /// It decrypts the passed data by using a CryptoBundle (aka a certificate).
    /// - Parameters:
    ///   - data: The data that needs to be Decrypted.
    ///   - preferredKey: The preferred SecKey that should be used to decrypt it. By default it uses the `.privateKey`.
    ///   - bundle: The Certificate that has been used to encrypt the data.
    /// - Returns: The clear data, or nil if it fails.
    public static func decrypt(data: Data,
                               preferredKey: CryptographicKey = .privateKey,
                               with bundle: CryptoBundle) -> Data? {
        return manage(data, for: .decrypt, preferredKey: preferredKey, using: bundle)
    }
    
    /// It decrypts the passed data by using a SecKey (a public key).
    /// - Parameters:
    ///   - data: The data that needs to be Decrypted.
    ///   - key: The public key from the corresponding private key, used to encrypt the string.
    /// - Returns: The clear data, or nil if it fails.
    public static func decrypt(data: Data,
                               with key: SecKey) -> Data? {
        return newDecrypt(data, decryptionKey: key)
    }
    
    
    /// Encrypts the data passed by using a CryptoBundle (aka a certificate).
    /// - Parameters:
    ///   - data: The data that needs to be Encrypted.
    ///   - preferredKey: The preferred SecKey that should be used to encrypt it. By default it uses the `.publicKey`.
    ///   - bundle: The Certificate that has been used to encrypt the data.
    /// - Returns: The encrypted data, or nil if it fails.
    public static func encrypt(data: Data,
                               preferredKey: CryptographicKey = .publicKey,
                               with bundle: CryptoBundle) -> Data? {
        return manage(data, for: .encrypt, preferredKey: preferredKey, using: bundle)
    }
    
    /// It decrypts the passed data by using a KeyPair (aka a a pair of  private and public key, generated by the SDK when you call `encrypt(data: Data, preferredKey: CertificateKey = .publicKey)`).
    /// - Parameters:
    ///   - data: The data that needs to be Decrypted.
    ///   - preferredKey: The preferred SecKey that should be used to decrypt it. By default it uses the `.privateKey`.
    ///   - pair: The KeyPair that was used to Encrypt the data.
    /// - Returns:  The clear data, or nil if it fails.
    public static func decrypt(data: Data,
                               preferredKey: CryptographicKey = .privateKey,
                               with pair: KeyPair) -> (KeyPair?, Data?) {
        return manage(data, pair: pair, preferredKey: preferredKey, for: .decrypt)
    }
    
    /// It encrypts the passed data by using a KeyPair (aka a a pair of  private and public key, that is generated at the moment of the call).
    /// - Parameters:
    ///   - data: The data that needs to be Encrypted.
    ///   - preferredKey: The preferred SecKey that should be used to encrypt it. By default it uses the `.publicKey`.
    /// - Returns: A touple containing the KeyPair that has been generated and the EncryptedData.
    public static func encrypt(data: Data,
                               preferredKey: CryptographicKey = .publicKey) -> (KeyPair?, Data?) {
        return manage(data, preferredKey: preferredKey, for: .encrypt)
    }
    
    /// It decrypts the passed data by using a SecKey (a public key).
    /// - Parameters:
    ///   - string: The string that needs to be Decrypted.
    ///   - key: The public key from the corresponding private key, used to encrypt the string.
    /// - Returns: The clear data, or nil if it fails.
    public static func decrypt(string: String,
                               with key: SecKey) -> Data? {
        guard let data = Data(base64Encoded: string) else {
            return nil
        }
        return newDecrypt(data, decryptionKey: key)
    }
    
    public static func decrypt(string: String,
                               preferredKey: CryptographicKey = .privateKey,
                               with bundle: CryptoBundle) -> Data? {
        guard let data = Data(base64Encoded: string) else {
            return nil
        }
        return manage(data, for: .decrypt, preferredKey: preferredKey, using: bundle)
    }
    
    
    public static func encrypt(string: String,
                               preferredKey: CryptographicKey = .publicKey,
                               with bundle: CryptoBundle) -> Data? {
        guard let data = string.data(using: .utf8) else {
            return nil
        }
        return manage(data, for: .encrypt, preferredKey: preferredKey, using: bundle)
    }
    
    public static func decrypt(string: String,
                               preferredKey: CryptographicKey = .privateKey,
                               with pair: KeyPair) -> (KeyPair?, Data?) {
        guard let data = Data(base64Encoded: string) else {
            return (nil, nil)
        }
        return manage(data, pair: pair, preferredKey: preferredKey, for: .decrypt)
    }
    
    public static func encrypt(string: String,
                               preferredKey: CryptographicKey = .publicKey) -> (KeyPair?, Data?) {
        guard let data = string.data(using: .utf8) else {
            return (nil, nil)
        }
        return manage(data, preferredKey: preferredKey, for: .encrypt)
    }
    
}

// MARK: -Actual decryption/encryption
private extension SecurityRSA {
    
    static func manage(_ value: Data,
                       pair: KeyPair? = nil,
                       preferredKey: CryptographicKey,
                       for cryptoAction: CryptoAction) -> (KeyPair?, Data?) {
        
        if cryptoAction == .encrypt {
            if let pair = pair {
                return (pair, newEncrypt(value, encryptionKey: pair.publicKey))
            } else if let newPair = KeyPair.newPair(for: bundle) {
                return (newPair, newEncrypt(value, encryptionKey: newPair.publicKey))
            } else {
                return (nil, nil)
            }
        } else {
            if let pair = pair {
                return (pair, newDecrypt(value, decryptionKey: pair.privateKey))
            } else if let newPair = KeyPair.newPair(for: bundle) {
                return (newPair, newDecrypt(value, decryptionKey: newPair.privateKey))
            } else {
                return (nil, nil)
            }
        }
    }
    
    static func manage(_ value: Data,
                       for cryptoAction: CryptoAction,
                       preferredKey: CryptographicKey,
                       using bundle: CryptoBundle) -> Data? {
        var trust: SecTrust?

        // Retrieve a SecTrust using the SecCertificate object. Provide X509 as policy
        let status = SecTrustCreateWithCertificates(bundle.certificate, SecPolicyCreateBasicX509(), &trust)

        // Check if the trust generation is success
        guard status == errSecSuccess else { return nil }

        let key: SecKey
        switch preferredKey {
        case .privateKey:
            var privateKey: SecKey?
            SecIdentityCopyPrivateKey(bundle.identity, &privateKey)
            guard let secKey = privateKey else { return nil }
            key = secKey
        case .publicKey:
            // Retrieve the SecKey using the trust hence generated
            if #available(iOS 14.0, *), #available(macOS 11.0, *) {
                guard let secKey = SecTrustCopyKey(trust!) else { return nil }
                key = secKey
            } else {
                guard let secKey = SecTrustCopyPublicKey(trust!) else { return nil }
                key = secKey
            }
        }
      
        if cryptoAction == .encrypt {
            return newEncrypt(value, encryptionKey: key)
        } else {
            return newDecrypt(value, decryptionKey: key)
        }
    }
    
    static func newEncrypt(_ value: Data, encryptionKey: SecKey) -> Data? {
        let coreFData = value as CFData
        return SecKeyCreateEncryptedData(encryptionKey, preferredAlgorithm, coreFData, nil) as Data?
    }
    
    static func newDecrypt(_ data: Data, decryptionKey: SecKey) -> Data? {
        let coreFData = data as CFData
        
        guard let decrypt = SecKeyCreateDecryptedData(decryptionKey, preferredAlgorithm, coreFData, nil) as Data? else {
            return nil
        }
        return decrypt
    }
}
