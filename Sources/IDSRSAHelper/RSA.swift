//
//  Crypto.swift
//  IDSignQRGenerator
//
//  Created by Francesco Bianco on 22/12/21.
//

import Foundation
import Security

public struct RSA {
    
    public static var preferredAlgorithm: SecKeyAlgorithm = .rsaEncryptionPKCS1
    public static var bundle: String = {
        return Bundle.main.bundleIdentifier ?? "com.certificatehelper"
    }()
    
    public struct CryptoBundle {
        var certificate: SecCertificate
        var identity: SecIdentity
        
        /// Given a p12 certificate and the corresponding password, it tries initialize the CryptoBundle instance.
        /// - p12Data: The data that represents the certificate.
        /// - password: The password to unlock the certificate.
        public init?(from p12Data: Data, password: String) {
            var items: CFArray?
            let certOptions: CFDictionary = [kSecImportExportPassphrase as String: password] as CFDictionary
            
            // import certificate to read its entries
            let securityError = SecPKCS12Import(p12Data as CFData, certOptions, &items)
            
            guard let certItems = items, securityError == errSecSuccess else {
                return nil
            }
            
            let certItemsArray: Array = certItems as Array
            let dict: AnyObject? = certItemsArray.first
            
            guard let certEntry: Dictionary = dict as? [String: AnyObject] else {
                return nil
            }
            
            // grab the identity
            guard let secIdentity = SecIdentity.conditionallyCast(certEntry["identity"]) else {
                return nil
            }
            
            // grab the certificate chain
            var certRef: SecCertificate?
            SecIdentityCopyCertificate(secIdentity, &certRef)
            guard let cert = certRef else {
                return nil
            }
            self.certificate = cert
            self.identity = secIdentity
        }
    }
    
    /// Describes what SecCertificate SecKey should be used to ecnrypt/decrypt a piece of data.
    public enum CertificateKey: Int, Hashable {
        case privateKey = 0
        case publicKey = 1
    }
    
    enum CryptoAction {
        case encrypt
        case decrypt
        
        var keyToUse: CertificateKey {
            switch self {
            case .encrypt:
                return .publicKey
            case .decrypt:
                return .privateKey
            }
        }
    }
    
    // MARK: - API
    
    /// It decrypts the passed data by using a CryptoBundle (aka a certificate).
    /// - Parameters:
    ///   - data: The data that needs to be Decrypted.
    ///   - preferredKey: The preferred SecKey that should be used to decrypt it. By default it uses the `.privateKey`.
    ///   - bundle: The Certificate that has been used to encrypt the data.
    /// - Returns: The clear data, or nil if it fails.
    public static func decrypt(data: Data,
                               preferredKey: CertificateKey = .privateKey,
                               with bundle: CryptoBundle) -> Data? {
        return manage(data, for: .decrypt, preferredKey: preferredKey, using: bundle)
    }
    
    
    /// Encrypts the data passed by using a CryptoBundle (aka a certificate).
    /// - Parameters:
    ///   - data: The data that needs to be Encrypted.
    ///   - preferredKey: The preferred SecKey that should be used to encrypt it. By default it uses the `.publicKey`.
    ///   - bundle: The Certificate that has been used to encrypt the data.
    /// - Returns: The encrypted data, or nil if it fails.
    public static func encrypt(data: Data,
                               preferredKey: CertificateKey = .publicKey,
                               with bundle: CryptoBundle) -> Data? {
        return manage(data, for: .encrypt, preferredKey: preferredKey, using: bundle)
    }
    
    /// It decrypts the passed data by using a KeyPair (aka a a pair of  private and public key, generated by the SDK when you call `encrypt(data: Data, preferredKey: CertificateKey = .publicKey)`).
    /// - Parameters:
    ///   - data: The data that needs to be Decrypted.
    ///   - preferredKey: The preferred SecKey that should be used to decrypt it. By default it uses the `.privateKey`.
    ///   - pair: The KeyPair that was used to Encrypt the data.
    /// - Returns:  The clear data, or nil if it fails.
    public static func decrypt(data: Data,
                               preferredKey: CertificateKey = .privateKey,
                               with pair: KeyPair) -> (KeyPair?, Data?) {
        return manage(data, pair: pair, preferredKey: preferredKey, for: .decrypt)
    }
    
    /// It encrypts the passed data by using a KeyPair (aka a a pair of  private and public key, that is generated at the moment of the call).
    /// - Parameters:
    ///   - data: The data that needs to be Encrypted.
    ///   - preferredKey: The preferred SecKey that should be used to encrypt it. By default it uses the `.publicKey`.
    /// - Returns: A touple containing the KeyPair that has been generated and the EncryptedData.
    public static func encrypt(data: Data,
                               preferredKey: CertificateKey = .publicKey) -> (KeyPair?, Data?) {
        return manage(data, preferredKey: preferredKey, for: .encrypt)
    }
    
    public static func decrypt(string: String,
                               preferredKey: CertificateKey = .privateKey,
                               with bundle: CryptoBundle) -> Data? {
        guard let data = Data(base64Encoded: string) else {
            return nil
        }
        return manage(data, for: .decrypt, preferredKey: preferredKey, using: bundle)
    }
    
    
    public static func encrypt(string: String,
                               preferredKey: CertificateKey = .publicKey,
                               with bundle: CryptoBundle) -> Data? {
        guard let data = string.data(using: .utf8) else {
            return nil
        }
        return manage(data, for: .encrypt, preferredKey: preferredKey, using: bundle)
    }
    
    public static func decrypt(string: String,
                               preferredKey: CertificateKey = .privateKey,
                               with pair: KeyPair) -> (KeyPair?, Data?) {
        guard let data = Data(base64Encoded: string) else {
            return (nil, nil)
        }
        return manage(data, pair: pair, preferredKey: preferredKey, for: .decrypt)
    }
    
    public static func encrypt(string: String,
                               preferredKey: CertificateKey = .publicKey) -> (KeyPair?, Data?) {
        guard let data = string.data(using: .utf8) else {
            return (nil, nil)
        }
        return manage(data, preferredKey: preferredKey, for: .encrypt)
    }
    
}

// MARK: -Actual decryption/encryption
private extension RSA {
    
    static func manage(_ value: Data,
                       pair: KeyPair? = nil,
                       preferredKey: CertificateKey,
                       for cryptoAction: CryptoAction) -> (KeyPair?, Data?) {
        
        if cryptoAction == .encrypt {
            if let pair = pair {
                return (pair, newEncrypt(value, encryptionKey: pair.publicKey))
            } else if let newPair = KeyPair.newPair(for: bundle) {
                return (newPair, newEncrypt(value, encryptionKey: newPair.publicKey))
            } else {
                return (nil, nil)
            }
        } else {
            if let pair = pair {
                return (pair, newDecrypt(value, decryptionKey: pair.privateKey))
            } else if let newPair = KeyPair.newPair(for: bundle) {
                return (newPair, newDecrypt(value, decryptionKey: newPair.privateKey))
            } else {
                return (nil, nil)
            }
        }
    }
    
    static func manage(_ value: Data,
                       for cryptoAction: CryptoAction,
                       preferredKey: CertificateKey,
                       using bundle: CryptoBundle) -> Data? {
        var trust: SecTrust?

        // Retrieve a SecTrust using the SecCertificate object. Provide X509 as policy
        let status = SecTrustCreateWithCertificates(bundle.certificate, SecPolicyCreateBasicX509(), &trust)

        // Check if the trust generation is success
        guard status == errSecSuccess else { return nil }

        let key: SecKey
        switch preferredKey {
        case .privateKey:
            var privateKey: SecKey?
            SecIdentityCopyPrivateKey(bundle.identity, &privateKey)
            guard let secKey = privateKey else { return nil }
            key = secKey
        case .publicKey:
            // Retrieve the SecKey using the trust hence generated
            if #available(iOS 14.0, *), #available(macOS 11.0, *) {
                guard let secKey = SecTrustCopyKey(trust!) else { return nil }
                key = secKey
            } else {
                guard let secKey = SecTrustCopyPublicKey(trust!) else { return nil }
                key = secKey
            }
        }
      
        if cryptoAction == .encrypt {
            return newEncrypt(value, encryptionKey: key)
        } else {
            return newDecrypt(value, decryptionKey: key)
        }
    }
    
    static func newEncrypt(_ value: Data, encryptionKey: SecKey) -> Data? {
        let coreFData = value as CFData
        return SecKeyCreateEncryptedData(encryptionKey, preferredAlgorithm, coreFData, nil) as Data?
    }
    
    static func newDecrypt(_ data: Data, decryptionKey: SecKey) -> Data? {
        let coreFData = data as CFData
        
        guard let decrypt = SecKeyCreateDecryptedData(decryptionKey, preferredAlgorithm, coreFData, nil) as Data? else {
            return nil
        }
        return decrypt
    }
}
